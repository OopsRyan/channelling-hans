<!DOCTYPE html>
<html lang="en" class="tas-com">

<head>
    <meta charset="utf-8">
    <title>Gapminder World</title>
    <link href="./themes/prism.css" rel="stylesheet" />
    <link href="./themes/tas_style.css" rel="stylesheet" />
    <script type="text/javascript" src="./lib/d3.v4.js" charset="utf-8"></script>
    <link href="https://fonts.googleapis.com/css?family=Poppins|Raleway|Roboto+Mono|Varela+Round" rel="stylesheet">
    <script src="./lib/prism.js" charset="utf-8"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/topojson/1.6.9/topojson.min.js"></script>
    <script src="//d3js.org/d3-geo-projection.v1.min.js"></script>
    <script src="./lib/topojson.min.js"></script>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">
    <!-- tomorrow  dark-->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>
    hljs.initHighlightingOnLoad();
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style type="text/css">
    .axis path,
    .axis line {
        fill: none;
        stroke: black;
        shape-rendering: crispEdges;
    }

    .axis text {
        font-family: sans-serif;
        font-size: 11px;
    }

    .grid .tick {
        stroke: lightgrey;
        opacity: 0.3;
        stroke-dasharray: 1, 3;
    }

    .graticule {
        fill: none;
        stroke: #777;
        stroke-width: 0.5px;
        stroke-opacity: 0.5;
    }

    .land {
        fill: #DCDCDC;
    }

    .boundary {
        fill: none;
        stroke: #fff;
        stroke-width: 0.5px;
    }

    .tip {
        position: absolute;
        width: auto;
        height: auto;
        font-family: simsun;
        font-size: 20px;
        text-align: center;
        border-style: solid;
        border-width: 2px;
        background-color: white;
        border-radius: 7px;
    }

    .tip .tip_title {
        border-bottom: 1px solid #000;
        text-align: center;
    }

    .tip .tip_detail {
        /*inline will inherit its parent div's text align*/
        display: inline;
        /*text-align: left;*/
    }

    .hover-line {
        stroke: rgb(148, 33, 147);
        stroke-width: 2px;
        stroke-dasharray: 3, 3;
    }

    @media screen and (min-width: 1300px) {
        .map {
            float: left;
            width: 65%;
        }
        .chart_label_container {
            float: left;
            width: 35%;
        }
        .play_btn {
            float: left;
            margin-left: 50px;
        }
        .time_line {
            margin-left: 70px;
            line-height: 40px;
            width: 70%;
        }
    }

    @media screen and (max-width: 1300px) {
        .map {
            float: left;
            width: 100%;
        }
        .chart_label_container {
            float: left;
            width: 100%;
        }
        .play_btn {
            float: left;
        }
        .time_line {
            margin-left: 70px;
            line-height: 40px;
            width: 70%;
        }
    }
    </style>
</head>

<body>
    <!-- 
    <h1>Gapminder World</h1>
    <h2>Mapping the Wealth and Health of Nations</h2>
 -->
    <div id="bubble_div">
        <h2>#### Author: Qirun Chen (Student No. 16212138) -- An homage to Hans Rosling</h2>
        <div style="display:table;box-sizing:border-box;width:100%;">
            <pre style="float:left;width:50%">
                <code class="python hljs">
                #-----------> Introduction
                #-----> Play
                if play_button_status is play:
                    animation() 
                    if country_checkbox is checked:
                        fade_out_countries()
                        if show_traces is checked:
                            show_traces()
                        if show_lines is checked:
                            show_lines()
                    else:
                        if mouse_over_worldmap or mouse_over_color_labels:
                            fade_out_countries()
                </code>
            </pre>
            <pre style="float:left;width:50%">
                <code class="python">
        #-----> Pause
        elif play_button_status is pause: 
            if mouse_over_circles:
                draw_focus_line()
                look_up_details()
            elif mouse_over_worldmap:
                look_up_a_certain_country() 
                if country_checkbox is not checked:
                    fade_out_countries()
            elif mouse_over_color_labels:
                if country_checkboxs is not checked:
                    fade_out_countries()
            elif timeline_changed:
                animation()
                </code>
            </pre>
        </div>
        <div class="map">
            <div id="bubble_chart_div" style="height:70%">
                <script type="text/javascript">
                // Define margins
                var margin = { top: 10, right: 500, bottom: 60, left: 60 };

                var label_svg = { width: 130, height: 210, padding: 20, side: 20, margin_top: 30 };

                var geo_map = { width: 460, height: 240 };

                //Width and height
                var outer_width = 1400;
                var outer_height = 600;
                var svg_width = outer_width - margin.left - margin.right;
                var svg_height = outer_height - margin.top - margin.bottom;

                // The year to display
                min_year = null;
                max_year = null;
                display_year = null;

                // dataset
                dataset = null;

                // checked_country
                checked_country = [];

                // play status => true : play  /  false : pause
                play_status = false;

                // if the color label is choosen, filter out the circles with other color labels; if not, it is null
                // assigned with region name and used with country_region dict
                color_label = null;

                var initial_interval = 300;
                var interval = initial_interval;

                // set intial circle attribute 
                initial_circle_opacity = 1;
                hidden_circle_opacity = .2;
                initial_text_opacity = 0;

                // assign colors to different areas
                colors_areas = {
                    "Asia": "rgb(255,38,0)",
                    "Oceania": "rgb(255,38,0)",
                    "Australia": "rgb(255,38,0)",
                    "North America": "rgb(0,142,0)",
                    "Central America": "rgb(0,142,0)",
                    "South America": "rgb(0,142,0)",
                    "Europe": "rgb(255,179,2)",
                    "Africa": "rgb(4,51,255)"
                };

                //Create SVG element as a group with the margins transform applied to it
                var svg = d3.select("#bubble_chart_div")
                    .append("svg")
                    .attr("id", "bubble_chart")
                    // .attr("width", svg_width + margin.left*1.3)
                    // .attr("height", svg_height + margin.top + margin.bottom)
                    // .attr("transform", "scale(0.7)")
                    .attr("viewBox", "0 0 " + (svg_width + margin.left * 1.3) + " " + (svg_height + margin.top + margin.bottom))
                    .attr("preserveAspectRatio", "xMinYMin meet")
                    .append("g")
                    .attr("class", "chart")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                initialize_titles();

                // Gapminder_Small
                // ./data/Gapminder_All_Time.csv
                // Load the file data.csv and generate a visualisation based on it
                d3.csv("./data/Gapminder_All_Time.csv", function(error, data) {

                    // handle any data loading errors
                    if (error) {
                        console.log("Something went wrong");
                        console.log(error);
                    } else {
                        console.log("Data Loaded");

                        // Assign  the data object loaded to the global dataset variable
                        dataset = data;

                        year_list = d3.map(dataset, function(d) { return +d.Year; }).keys();
                        // sort year_list in ascending order
                        year_list = year_list.sort(function(x, y) {
                            return +d3.ascending(+x, +y);
                        })
                        min_year = d3.min(dataset.map(function(d) { return +d.Year; }));
                        max_year = d3.max(dataset.map(function(d) { return +d.Year; }));

                        initialize_slider();

                        display_year = min_year;

                        // radius scale
                        rScale = d3.scaleSqrt().domain([0, 5e8]).range([3, 30]);

                        initialize_axis();

                        d3.select(".chart").append("g").attr("class", "bubbles");

                        initialize_color_labels();

                        initialize_focus_point();

                        // Generate the visualisation
                        generateVis();

                        initialize_geo_map();

                        initialize_checkbox();

                        initialize_region_barchart();

                        initialize_govern_barchart();

                        draw_region_barchart();

                        draw_govern_barchart();
                    }
                });

                var filtered_dataset = null;
                // Define a fucntion to draw a simple bar chart
                function generateVis() {

                    // update checked country array each time
                    checked_country = get_checked_country();

                    // Filter the data to only include the current year
                    filtered_dataset = dataset.filter(function(d) {
                        return +d.Year == display_year;
                    });

                    d3.selectAll("#traces").remove();

                    /******** PERFORM DATA JOIN ************/
                    // data function => the second parameter => joining index 
                    // without the index, when the length of data increases, the order of joining will be a mass.
                    var bubbles = d3.select(".bubbles")
                        .selectAll("circle")
                        .data(filtered_dataset, function(d) { return d.Country; });

                    var texts = d3.select(".bubbles")
                        .selectAll("text")
                        .data(filtered_dataset, function(d) { return d.Country; });

                    /******** HANDLE UPDATE SELECTION ************/
                    // Update the display of existing elelemnts to mathc new data

                    // old version with g element.... now it makes no sense
                    // selectAll => selection object
                    // selection.transition => transition object
                    // note: filtered_dataset is joined with bubbles. so only the anonymous function of the bubbles have access to filtered data, the anonymous function of old bubbles has the first initialized data.
                    // this is why i have to use filter again.

                    bubbles
                        .transition()
                        .duration(interval)
                        .ease(d3.easeQuad)
                        .attr("cx", function(d) { return xScale(+d.GDP); })
                        .attr("cy", function(d) { return yScale(+d.LifeExp); })
                        .attr("r", function(d, i) {
                            return rScale(+d.Population);
                        })
                        .style("opacity", function(d) {
                            if (checked_country.length > 0 && !checked_country.includes(d.Country)) {
                                return hidden_circle_opacity;
                            } else if (color_label != null) {
                                return (colors_areas[d.Region] != colors_areas[color_label] ? hidden_circle_opacity : initial_circle_opacity)
                            } else {
                                return initial_circle_opacity;
                            }
                        });

                    texts.transition()
                        .duration(interval)
                        .attr("x", function(d) { return xScale(+d.GDP) + rScale(+d.Population); })
                        .attr("y", function(d) { return yScale(+d.LifeExp); })
                        .attr("visibility", function(d) {
                            if (checked_country.length > 0 && checked_country.includes(d.Country)) {
                                return "visible";
                            } else {
                                return "hidden";
                            }
                        }); //hidden or visible

                    /******** HANDLE ENTER SELECTION ************/
                    // Create new elements in the dataset
                    bubbles.enter()
                        .append("circle")
                        .attr("id", function(d) { return "circle_" + d.Country; })
                        .attr("cx", function(d) { return xScale(+d.GDP); })
                        .attr("cy", function(d) { return yScale(+d.LifeExp); })
                        .style("fill", function(d) {
                            return colors_areas[d.Region];
                        })
                        .style("pointer-events", "all")
                        .style("stroke", "black")
                        .style("stroke-width", 0.5)
                        .style("opacity", function(d) {

                            if (checked_country.length > 0 && !checked_country.includes(d.Country)) {
                                return hidden_circle_opacity;
                            } else {
                                return initial_circle_opacity;
                            }

                        })
                        .on('mouseover', function(d, i) {

                            // when the status is paused, the focus line can be draw.
                            if (!play_status) {

                                // fade(d.Region);
                                focus_line.style("display", null);

                                // old version with g element.. now it make no sense...~~~
                                // get circle's parent g's transform position
                                // transform_matrix = this.parentNode.transform.baseVal.consolidate().matrix;

                                draw_focus_line(d);
                            }

                        })
                        .on('mouseout', function(d, i) {

                            // fade_out()

                            focus_line.style("display", "none");
                            focus_tip.style("opacity", 0.0);
                        })
                        .on('click', function(d, i) {

                            // if(!checked_country.includes(d.Country)){
                            //     checked_country.push(d.Country)
                            // }

                            // fade_by_country(d.Country)

                            // for (var i = checked_country.length - 1; i >= 0; i--) {
                            //     d3.select("#text_"+checked_country[i])
                            //         .transition()
                            //         .attr("visibility", "visible")                               
                            // }

                        })
                        .transition()
                        .duration(interval)
                        .ease(d3.easeQuad)
                        .attr("r", function(d) {
                            return rScale(+d.Population);
                        });


                    texts.enter()
                        .append("text")
                        .attr("id", function(d) { return "text_" + d.Country })
                        .text(function(d) { return d.Country; })
                        .attr("text-anchor", "start")
                        .attr("visibility", function(d) {

                            if (checked_country.length > 0 && checked_country.includes(d.Country)) {
                                return "visible";
                            } else {
                                return "hidden";
                            }
                        }) //hidden or visible
                        .attr("font-size", "20px")
                        // .style("opacity", initial_text_opacity)
                        .attr("x", function(d) { return xScale(+d.GDP) + rScale(+d.Population); })
                        .attr("y", function(d) { return yScale(+d.LifeExp); });


                    /******** HANDLE EXIT SELECTION ************/
                    // Remove bars that not longer have a matching data eleement
                    bubbles.exit()
                        // .transition()
                        // .duration(300)
                        // .ease(d3.easeLinear)
                        // .style("fill", "red")
                        // .attr("r", +0)
                        .remove();

                    texts.exit().remove();

                    // start traces
                    if (document.getElementById("trace_checkBox").checked || document.getElementById("line_checkBox").checked) {
                        create_traces()
                    }


                    // Set the year label
                    // d3.select("#year_header").text(display_year)
                    d3.select("#year_middle").text(display_year);
                }

                function create_traces() {

                    // ############################################
                    // circle's traces enter......
                    trace_dataset = dataset.filter(function(d) {
                        if (checked_country.length > 0) {
                            return checked_country.includes(d.Country) && display_year >= +d.Year;
                        }
                        return false;
                    })

                    var traces = d3.select(".bubbles")

                    path_dict = {}
                    for (var i = checked_country.length - 1; i >= 0; i--) {
                        path_dict[checked_country[i]] = ""
                    }

                    for (var i = 0; i < trace_dataset.length - 1; i++) {
                        var circle_data = trace_dataset[i]

                        if (document.getElementById("trace_checkBox").checked) {

                            traces.append("circle")
                                .attr("id", "traces")
                                .attr("cx", xScale(+trace_dataset[i].GDP))
                                .attr("cy", yScale(+trace_dataset[i].LifeExp))
                                .attr("r", rScale(+trace_dataset[i].Population))
                                .style("fill", colors_areas[trace_dataset[i].Region])
                                .style("pointer-events", "all")
                                .style("stroke", "black")
                                .style("stroke-width", 0.1)
                                .style("opacity", initial_circle_opacity)
                        }

                        if (document.getElementById("line_checkBox").checked) {
                            if (path_dict[trace_dataset[i].Country] == "") {
                                path_dict[trace_dataset[i].Country] += "M " + xScale(+trace_dataset[i].GDP) + " " + yScale(+trace_dataset[i].LifeExp)
                            } else {
                                path_dict[trace_dataset[i].Country] += " L " + xScale(+trace_dataset[i].GDP) + " " + yScale(+trace_dataset[i].LifeExp)
                            }
                        }
                    }

                    if (document.getElementById("line_checkBox").checked) {
                        for (var i = checked_country.length - 1; i >= 0; i--) {
                            traces.append("path")
                                .attr("d", path_dict[checked_country[i]])
                                .attr("id", "traces")
                                .attr("stroke", colors_areas[country_region_dict[checked_country[i]]])
                                .attr("stroke-width", "2")
                                .attr("fill", "none")
                        }
                    }

                }

                function fade(type) {
                    svg.selectAll("circle")
                        .filter(function(d) {
                            return colors_areas[d.Region] != colors_areas[type];
                        })
                        .transition()
                        .style("opacity", hidden_circle_opacity);
                }

                function fade_by_country(country_name) {

                    d3.selectAll("circle")
                        .filter(function(d) {
                            return !checked_country.includes(d.Country);
                        })
                        .transition()
                        .style("opacity", hidden_circle_opacity);
                }

                function fade_out() {
                    svg.selectAll("circle")
                        .transition()
                        .style("opacity", initial_circle_opacity);
                }

                var timer;

                function play() {

                    clearInterval(timer);

                    timer = setInterval(function() {
                        // Iterate through avilable years, since years may have interval, for example, 1900, 1910, 1920, 1950, 1951, 1952...
                        // setInterval return an interval ID which can be passed to clearInterval                    
                        // before update, set slider value first. !!!!!
                        // otherwise, the slider will go ahead and the slider onclick event makes no sense.!!! important!!!
                        var slider = d3.select("#year_slider")
                        display_year = +slider.property("value") + 1;
                        if (!year_list.includes("" + display_year)) {
                            if (display_year <= max_year) {
                                var years_more_than_this = year_list.filter(function(year) {
                                    return display_year < +year;
                                })
                                display_year = years_more_than_this[0];
                            } else {
                                display_year = min_year;
                            }
                        }

                        slider.property("value", display_year);

                        generateVis();
                        draw_region_barchart();
                        draw_govern_barchart();
                    }, interval);
                }

                function pause() {
                    clearInterval(timer);
                }

                function get_checked_country() {

                    // convert nodelist to array, because map needs an iteratable object
                    var checked_country = Array.from(d3.selectAll(".country_checkbox:checked")._groups[0]);
                    // console.log(checked_country)
                    return checked_country.map(function(d) { return d.value; })
                }

                function initialize_color_labels() {
                    // var label_g = d3.select("#bubble_chart")
                    //     .append("g")
                    //     .attr("id", "label_g")
                    //     .attr("x", svg_width + label_svg.width)
                    //     .attr("y", 0)
                    //     .attr("transform", "translate("+(svg_width+margin.left+10)+","+-margin.top+")")

                    var label_g = d3.select("#bubble_label_div")
                        .append("svg")
                        .attr("id", "label_svg")
                        .attr("viewBox", "0 0 " + label_svg.width * 1.5 + " " + label_svg.height * 1.5)
                        .attr("preserveAspectRatio", "xMinYMin meet")
                        .attr("height", label_svg.height)
                        .attr("width", label_svg.width)

                    var keys = Object.keys(colors_areas);

                    // console.log(label_g)
                    for (var i = 0; i < keys.length; i++) {

                        var g = label_g.append("g")

                        if (i > 0 && colors_areas[keys[i]] == colors_areas[keys[i - 1]]) {

                        } else {
                            g.append("rect")
                                .style("fill", colors_areas[keys[i]])
                                .attr("name", keys[i])
                                .attr("y", label_svg.side * i * 1.5 + label_svg.margin_top)
                                .attr("x", 0)
                                .attr("width", label_svg.side)
                                .attr("height", label_svg.side)
                                .on('mouseover', function() {
                                    if (checked_country.length <= 0) {
                                        if (play_status) {
                                            color_label = d3.select(this).attr("name");
                                        } else {
                                            fade(d3.select(this).attr("name"));
                                        }
                                    }
                                })
                                .on('mouseout', function() {
                                    if (checked_country.length <= 0) {
                                        if (play_status) {
                                            color_label = null;
                                        } else {
                                            fade_out();
                                        }
                                    }
                                })
                        }

                        g.append("text")
                            .text(keys[i])
                            .attr("text-anchor", "start")
                            .style("font-size", "20px")
                            .attr("x", label_svg.side * 0.5 + label_svg.padding)
                            .attr("y", label_svg.side * 1.5 * i + label_svg.side * 0.85 + label_svg.margin_top)
                    }
                }

                function initialize_focus_point() {
                    // append the focus lines
                    focus_line = d3.select("#bubble_chart").append("g")
                        .attr("class", "focus_line")
                        .style("display", "none")
                        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                    vertical_line = focus_line.append("line")
                        .attr("class", "hover-line")
                    horizontal_line = focus_line.append("line")
                        .attr("class", "hover-line")

                    // append focus tip text
                    focus_tip = d3.select('#bubble_div')
                        .append("div")
                        .attr("class", "tip")
                        .style("opacity", 0.0)

                    focus_title = focus_tip.append("div")
                        .attr("class", "tip_title")

                    focus_text = focus_tip.append("div").append("div")
                        .attr("class", "tip_detail")
                }

                function draw_focus_line(circle_data) {

                    var cx = xScale(+circle_data.GDP);
                    var cy = yScale(+circle_data.LifeExp);
                    var r = rScale(+circle_data.Population);

                    // set the start point and end point of vertical line 
                    vertical_line.attr("x1", cx)
                        .attr("y1", cy)
                        .attr("x2", cx)
                        .attr("y2", svg_height)

                    //set the start point and end point of horizontal line
                    horizontal_line.attr("x1", 0)
                        .attr("y1", cy)
                        .attr("x2", cx)
                        .attr("y2", cy)


                    focus_tip.style("left", d3.event.pageX + "px")
                        .style("top", d3.event.pageY + 20 + "px")
                        .style("opacity", 1.0)

                    focus_title.html(circle_data.Country + " " + circle_data.Year)

                    focus_text.html(
                        "GDP: " + circle_data.GDP + "<br>" +
                        "LifeExp: " + circle_data.LifeExp + "<br>" +
                        "Population: " + circle_data.Population + "<br>"
                    )
                }

                function initialize_axis() {
                    // Set up the scale to be used on the x axis
                    xScale = d3.scaleLinear();

                    // Set up the scale to be used on the y axis
                    yScale = d3.scaleLinear();

                    topScale = d3.scaleLinear().range([0, svg_width]);
                    rightScale = d3.scaleLinear().range([svg_height, 0]);
                    var topAxis = d3.axisTop().scale(topScale).ticks(0);
                    var rightAxis = d3.axisRight().scale(rightScale).ticks(0);

                    // Create an x-axis connected to the x scale
                    var xAxis = d3.axisBottom()
                        .scale(xScale);

                    //Define Y axis
                    var yAxis = d3.axisLeft()
                        .scale(yScale);

                    y_min = d3.min(dataset.map(function(d) { return +d.LifeExp; }));
                    y_max = d3.max(dataset.map(function(d) { return +d.LifeExp; }));
                    x_min = d3.min(dataset.map(function(d) { return +d.GDP; }));
                    x_max = d3.max(dataset.map(function(d) { return +d.GDP; }));

                    // Call axes
                    svg.append("g")
                        .attr("class", "axis")
                        .attr("id", "y-axis");

                    svg.append("g")
                        .attr("class", "axis")
                        .attr("id", "x-axis")
                        .attr("transform", "translate(0," + (svg_height) + ")");

                    svg.append("g")
                        .attr("class", "axis")
                        .call(topAxis);

                    svg.append("g")
                        .attr("class", "axis")
                        .attr("transform", "translate(" + (svg_width) + ",0)")
                        .call(rightAxis);

                    x_ticks = [500, 1000, 2000, 5000, 10000, 20000, 50000];
                    x_domain = [0].concat(x_ticks).concat([x_max]);

                    y_ticks = [50, 55, 60, 65, 70, 75, 80];
                    y_domain = [0].concat(y_ticks).concat([y_max]);

                    xScale.domain(x_domain)
                        .range([0, 50, 150, 250, 400, 500, 600, 750, svg_width]);

                    yScale.domain(y_domain)
                        .range([svg_height, 455, 390, 325, 260, 195, 130, 65, 0]);

                    //Define Y axis
                    var yAxis = d3.axisLeft()
                        .scale(yScale)
                        // .ticks(5);
                        .tickValues(y_ticks);

                    // Update the domain of the x scale
                    // Create an x-axis connected to the x scale
                    var xAxis = d3.axisBottom()
                        .scale(xScale)
                        // .ticks(5);
                        .tickValues(x_ticks);

                    svg.select("#x-axis").call(xAxis);
                    svg.select("#y-axis").call(yAxis);

                    // use css to draw grid dash lines
                    // add the X gridlines
                    svg.append("g")
                        .attr("class", "grid")
                        .attr("transform", "translate(0," + svg_height + ")")
                        .call(
                            d3.axisBottom(xScale).tickValues(x_ticks)
                            .tickSize(-svg_height)
                            .tickFormat("")
                        );
                    // add the Y gridlines
                    svg.append("g")
                        .attr("class", "grid")
                        .call(
                            d3.axisLeft(yScale).tickValues(y_ticks)
                            .tickSize(-svg_width)
                            .tickFormat("")
                        );

                }

                function initialize_titles() {

                    var title_1 = svg.append("text")
                        .attr("x", 30)
                        .attr("y", 30)
                        .attr("font-family", "serif")
                        .attr("font-size", "30px")
                        .attr("font-weight", "bold")
                        .text("Gapminder World")


                    var title_2 = svg.append("text")
                        .attr("x", 30)
                        .attr("y", 50)
                        .attr("font-family", "serif")
                        .attr("font-size", "15px")
                        .text("Mapping the Wealth and Health of Nations")

                    var title_year = svg.append("text")
                        .attr("x", 280)
                        .attr("y", 30)
                        .attr("font-family", "serif")
                        .attr("font-size", "30px")
                        .attr("font-weight", "bold")
                        .attr("id", "year_header");

                    var title_x_axis = svg.append("text")
                        .attr("x", 130)
                        .attr("y", 580)
                        .attr("font-family", "serif")
                        .attr("font-size", "20px")
                        .style("font-weight", "bold")
                        .text("INCOME PER PERSON")

                    var title_x_axis_unit_1 = svg.append("text")
                        .attr("x", 350)
                        .attr("y", 580)
                        .attr("font-family", "serif")
                        .attr("font-size", "15px")
                        .text("in US Dollars")

                    var title_x_axis_unit_1 = svg.append("text")
                        .attr("x", 440)
                        .attr("y", 580)
                        .attr("font-family", "serif")
                        .attr("font-size", "15px")
                        .attr("font-style", "italic")
                        .text("(GDP/capita, PPP$ in ation adjusted, log scale)")

                    var title_y_axis = svg.append("text")
                        .attr("x", -40)
                        .attr("y", 450)
                        .style("font-family", "serif")
                        .style("font-size", "20px")
                        .style("font-weight", "bold")
                        .attr("transform", "rotate(-90 -40,450)")
                        .text("LIFE EXPECTANCY")

                    var title_y_axis_unit = svg.append("text")
                        .attr("x", -40)
                        .attr("y", 255)
                        .style("font-family", "serif")
                        .style("font-size", "20px")
                        .attr("transform", "rotate(-90 -40,255)")
                        .text("in years")

                    var title_year = svg.append("text")
                        .attr("x", 30)
                        .attr("y", 140)
                        .attr("font-family", "'Varela Round', sans-serif") //'Roboto Mono', monospace //'Varela Round', sans-serif;
                        .attr("font-size", "100px")
                        .attr("font-weight", "bold")
                        .attr("id", "year_middle")
                        .style("fill", "#E0E0E0") //#C0C0C0
                        .attr("transform", "scale(2.5)");

                }

                function initialize_slider() {

                    slider_div = d3.select("#slider_div")
                    slider_div.append("span")
                        .attr("id", "min_year")
                        .style("height", "30px")
                        .style("width", "10%")
                        .html(min_year)
                    slider_div.append("input")
                        .attr("type", "range")
                        .attr("min", min_year)
                        .attr("max", max_year)
                        .attr("value", min_year)
                        .attr("step", 1)
                        .attr("id", "year_slider")
                        .style("width", "70%")
                        .style("height", "16px")
                        .on("input", function() {

                            current_value = d3.select(this).property("value")
                            if (!year_list.includes("" + current_value)) {
                                var years_more_than_this = year_list.filter(function(year) {
                                    return current_value < +year;
                                })
                                display_year = years_more_than_this[0];
                            } else {
                                // current_value must be in the range of slider, so no need to worry about being greater than max_year
                                display_year = current_value;
                            }

                            generateVis();
                            draw_region_barchart();
                            draw_govern_barchart();
                        });
                    slider_div.append("span")
                        .attr("id", "max_year")
                        .style("height", "30px")
                        .style("width", "10%")
                        .html(max_year)
                }

                function initialize_geo_map() {

                    var geo_map_svg = d3.select("#geo_map").append("svg");

                    geo_map_svg.attr("width", geo_map.width)
                        .attr("height", geo_map.height)
                        .attr("viewBox", "0 0 " + geo_map.width + " " + geo_map.height)
                        .attr("preserveAspectRatio", "xMinYMin meet")
                    // .attr("transform", "translate(0," + outer_height + ")");

                    // define the cylinder of the map
                    var projection = d3.geoCylindricalEqualArea()
                        .scale(90)
                        .translate([230, 120]) // translate the center position of the map in the svg
                        .precision(0.1);

                    // define geo-path creator
                    var path = d3.geoPath()
                        .projection(projection);

                    // draw net lines 
                    // var graticule = d3.geoGraticule();

                    // svg.append("path")
                    //     .datum(graticule)
                    //     .attr("class", "graticule")
                    //     .attr("d", path);

                    // svg.append("path")
                    //     .datum({type: "Sphere"})
                    //     .attr("class", "sphere")
                    //     .attr("d", path)
                    //     .attr("fill", "none")
                    //     .attr("stroke", "black");

                    country_dict = {};

                    function last_year_filter(value) {
                        return value.Year == max_year;
                    }

                    country_region = get_country_region(dataset.filter(last_year_filter));
                    // console.log(country_region)


                    d3.tsv("./data/world-country-names.tsv", function(error, data) {
                        if (error) throw error;

                        country_dict = {};
                        var standard_names = Object.keys(country_region);

                        // when loading country names with ids, handle with inconsistent country names.
                        for (var i = 0; i < data.length; i++) {
                            country_dict[data[i].id] = data[i].name;
                            for (var j = standard_names.length - 1; j >= 0; j--) {
                                if (data[i].name.indexOf(standard_names[j]) >= 0) {
                                    // console.log(data[i].name, standard_names[j])
                                    country_dict[data[i].id] = standard_names[j];
                                    break;
                                }
                            }
                        }
                        // console.log("after",country_dict)
                    });


                    // add text on each country
                    map_tip = d3.select('#bubble_div').append("div")
                        .attr("class", "tip")
                        .style("opacity", 0.0)

                    // assign data to world
                    d3.json("./data/world-110m.json", function(error, world) {
                        if (error) throw error;

                        var georoot = topojson.feature(world, world.objects.countries);

                        // initialize country id list
                        var countries = world.objects.countries.geometries;

                        var groups = geo_map_svg.append("g");

                        var path_binding = groups.selectAll("path")
                            .data(georoot.features);

                        // handle_inconsistent_names(country_region, country_dict);

                        var enter = path_binding.enter()
                            .insert("path")
                            // .datum(georoot.features)
                            .attr("class", "land")
                            .attr("d", path)
                            // d.id => country id in json data , i => the index in countries array
                            .style("fill", function(d, i) {
                                country_name = country_dict[+d.id];

                                // console.log(country_region[country_dict[+d.id]]);
                                return colors_areas[country_region[country_dict[+d.id]]];
                            })
                            // d.id => country id in json data , i => the index in countries array
                            .on('mouseover', function(d, i) {
                                // when some countries are checked, fade will damage the opacity.
                                // so only no coountry is checked, colors can be faded.
                                if (country_dict.hasOwnProperty(+d.id)) {
                                    // console.log(country_dict[+d.id])

                                    map_tip.html(country_dict[+d.id])
                                        .style("left", d3.event.pageX + "px")
                                        .style("top", (d3.event.pageY + 20) + "px")
                                        .style("opacity", 1.0)

                                    var curr_region = country_region[country_dict[+d.id]]
                                    if (Object.keys(colors_areas).indexOf(curr_region) > -1 && checked_country.length <= 0) {
                                        if (play_status) {
                                            color_label = curr_region;
                                        } else {
                                            fade(curr_region);
                                        }
                                    }
                                }
                                // d3.select(this).style("fill", "red")
                            })
                            .on('mousemove', function(d) {

                                map_tip.style("left", (d3.event.pageX) + "px")
                                    .style("top", (d3.event.pageY + 20) + "px")
                            })
                            .on('mouseout', function(d) {

                                map_tip.style("opacity", 0.0)

                                if (checked_country.length <= 0) {
                                    if (play_status) {
                                        color_label = null;
                                    } else {
                                        fade_out();
                                    }
                                }
                            })

                        // groups.append("path")
                        //     .datum(georoot)
                        //     .attr("class", "land")
                        //     .attr("d", path);

                        // draw the boundaries of countries
                        // svg.append("path")
                        //     .datum(topojson.mesh(world, world.objects.countries, function(a, b) { return a !== b; }))
                        //     .attr("class", "boundary")
                        //     .attr("d", path);
                    });
                }

                function initialize_checkbox() {

                    var scroll_box = d3.select("#country_checkbox_scroll")
                    scroll_box.style("overflow-y", "scroll")
                        .style("width", "200px")
                        .style("height", "250px")

                    // get country names and sort in alphabetical order
                    var country_name_array = Object.keys(country_region).sort(function(x, y) {
                        return d3.ascending(x, y);
                    });

                    for (var i = 0; i < country_name_array.length; i++) {
                        scroll_box.append("label")
                            .html("<input class='country_checkbox' value='" + country_name_array[i] + "' type='checkbox'>" + country_name_array[i] + "<br>")
                    }
                }

                region_xScale = null;
                region_yScale = null;
                barchart_height = 230;

                function initialize_region_barchart() {

                    var svg_width = 300
                    var margin = { left: 30, top: 10, right: 10, bottom: 70 }

                    var country_region_svg = d3.select("#country_region_barchart")
                        .append("svg")
                        .attr("width", svg_width + margin.left + margin.right)
                        .attr("height", barchart_height + margin.top + margin.bottom)
                        .append("g")
                        .attr("id", "region_svg")
                        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                    var region_dict = {}
                    var regions = Object.keys(colors_areas);
                    for (var i = regions.length - 1; i >= 0; i--) {
                        region_dict["" + regions[i]] = +filtered_dataset.filter(function(d) {
                            return d.Region == regions[i]
                        }).length
                    }

                    region_xScale = d3.scaleBand()
                        .range([0, svg_width])
                        .domain(regions)
                        .paddingInner(0.3)
                        .paddingOuter(0.5);

                    region_yScale = d3.scaleLinear()
                        .range([barchart_height, 0])
                        .domain([0, Math.max(...Object.values(region_dict))])

                    var xAxis = d3.axisBottom()
                        .scale(region_xScale);

                    var yAxis = d3.axisLeft()
                        .ticks(5)
                        .scale(region_yScale);

                    country_region_svg.append("g")
                        .attr("class", "axis")
                        .attr("transform", "translate(0," + barchart_height + ")")
                        .call(xAxis)
                        .selectAll("text")
                        .style("text-anchor", "end")
                        .attr("dx", "-.8em")
                        .attr("dy", ".15em")
                        .attr("transform", "rotate(-45)");

                    country_region_svg.append("g")
                        .attr("class", "axis")
                        .call(yAxis);
                }

                function draw_region_barchart() {

                    var region_data = []
                    var regions = Object.keys(colors_areas);
                    for (var i = regions.length - 1; i >= 0; i--) {
                        dict = {}
                        dict["Region"] = regions[i];
                        dict["Number"] = +filtered_dataset.filter(function(d) {
                            return d.Region == regions[i]
                        }).length;
                        region_data.push(dict)
                    }

                    console.log(region_data)

                    var bars = d3.select("#region_svg").selectAll("rect")
                        .data(region_data, function(d) { return d.Region; });

                    bars.transition()
                        .duration(interval)
                        .ease(d3.easeBounce)
                        .attr("y", function(d) {
                            return region_yScale(d.Number);
                        })
                        .attr("x", function(d) {
                            return region_xScale(d.Region);
                        })
                        .attr("height", function(d) {
                            return barchart_height - region_yScale(d.Number);
                        })
                        .attr("width", function(d) {
                            return region_xScale.bandwidth();
                        });


                    bars.enter()
                        .append("rect")
                        .transition()
                        .duration(interval)
                        .ease(d3.easeBounce)
                        .attr("y", function(d) {
                            return region_yScale(d.Number);
                        })
                        .attr("x", function(d) {
                            return region_xScale(d.Region);
                        })
                        .attr("height", function(d) {
                            console.log(barchart_height, region_yScale(d.Number))
                            return barchart_height - region_yScale(d.Number);
                        })
                        .attr("width", function(d) {
                            return region_xScale.bandwidth();
                        })
                        .style("fill", function(d) {
                            return colors_areas[d.Region];
                        });

                    bars.exit().remove();
                }

                govern_xScale = null;
                govern_yScale = null;

                function initialize_govern_barchart() {

                    var svg_width = 300
                    var margin = { left: 30, top: 10, right: 10, bottom: 120 }

                    var country_govern_svg = d3.select("#country_govern_barchart")
                        .append("svg")
                        .attr("width", svg_width + margin.left + margin.right)
                        .attr("height", barchart_height + margin.top + margin.bottom)
                        .append("g")
                        .attr("id", "govern_svg")
                        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                    var government_dict = {}
                    var governments = Array.from(new Set(filtered_dataset.map(function(d) { return d.Government; })));
                    for (var i = governments.length - 1; i >= 0; i--) {
                        government_dict["" + governments[i]] = +filtered_dataset.filter(function(d) {
                            return d.Government == governments[i]
                        }).length
                    }

                    govern_xScale = d3.scaleBand()
                        .range([0, svg_width])
                        .domain(governments)
                        .paddingInner(0.3)
                        .paddingOuter(0.5);

                    govern_yScale = d3.scaleLinear()
                        .range([barchart_height, 192, 152, 114, 76, 0])
                        .domain([0, 5, 10, 30, 40, Math.max(...Object.values(government_dict))])

                    var xAxis = d3.axisBottom()
                        .scale(govern_xScale);

                    var yAxis = d3.axisLeft()
                        .tickValues([0, 5, 10, 30, 40, Math.max(...Object.values(government_dict))])
                        .scale(govern_yScale);

                    country_govern_svg.append("g")
                        .attr("class", "axis")
                        .attr("transform", "translate(0," + barchart_height + ")")
                        .call(xAxis)
                        .selectAll("text")
                        .style("text-anchor", "end")
                        .attr("dx", "-.8em")
                        .attr("dy", ".15em")
                        .attr("transform", "rotate(-45)");

                    country_govern_svg.append("g")
                        .attr("class", "axis")
                        .call(yAxis);
                }

                function draw_govern_barchart() {

                    var government_data = []
                    var governments = Array.from(new Set(filtered_dataset.map(function(d) { return d.Government; })));
                    for (var i = governments.length - 1; i >= 0; i--) {
                        dict = {}
                        dict["Government"] = governments[i];
                        dict["Number"] = +filtered_dataset.filter(function(d) {
                            return d.Government == governments[i]
                        }).length;
                        government_data.push(dict)
                    }

                    console.log(government_data)

                    var bars = d3.select("#govern_svg").selectAll("rect")
                        .data(government_data, function(d) { return d.Government; });

                    bars.transition()
                        .duration(interval)
                        .ease(d3.easeBounce)
                        .attr("y", function(d) {
                            return govern_yScale(d.Number);
                        })
                        .attr("x", function(d) {
                            return govern_xScale(d.Government);
                        })
                        .attr("height", function(d) {
                            return barchart_height - govern_yScale(d.Number);
                        })
                        .attr("width", function(d) {
                            return govern_xScale.bandwidth();
                        })
                        .style("fill", "rgb(170,121,65)");


                    bars.enter()
                        .append("rect")
                        .transition()
                        .duration(interval)
                        .ease(d3.easeBounce)
                        .attr("y", function(d) {
                            return govern_yScale(d.Number);
                        })
                        .attr("x", function(d) {
                            return govern_xScale(d.Government);
                        })
                        .attr("height", function(d) {
                            return barchart_height - govern_yScale(d.Number);
                        })
                        .attr("width", function(d) {
                            return govern_xScale.bandwidth();
                        })
                        .style("fill", "rgb(170,121,65)");

                    bars.exit().remove();
                }

                var country_region_dict = {}

                function get_country_region(filtered_datset) {


                    for (var i = filtered_datset.length - 1; i >= 0; i--) {
                        country_region_dict[filtered_datset[i].Country] = filtered_datset[i].Region;
                    }
                    return country_region_dict;
                }

                function play_btn() {
                    var play_btn = d3.select('#play_btn')
                    if (play_btn.attr('src') == './themes/play_btn_icon.svg') {

                        play_btn.attr('src', './themes/pause_btn_icon.svg')
                        play_status = true
                        play()

                    } else {

                        play_btn.attr('src', './themes/play_btn_icon.svg')
                        play_status = false
                        pause()
                    }
                    // console.log(play_status)
                }

                function interval_change(checked_radio) {
                    interval = +checked_radio.value * initial_interval;
                }
                </script>
            </div>

    <div style="display: table;box-sizing:border-box;width:100%;">
        <div class="play_btn">
            <input id="play_btn" type="image" src="./themes/play_btn_icon.svg" style="width:40px;height:40px" onclick="play_btn()" />
        </div>
        <div id="slider_div" class="time_line">
        </div>
        <div style="display: table;box-sizing:border-box;width:100%;">
            <div style="float:left;margin-left:55px;width:40%;height:50%;">
                <br>
                <input id='trace_checkBox' type='checkbox'> Show Traces
                <input id='line_checkBox' type='checkbox'> Show Lines<br><br>
                <input type="radio" name="interval" onclick="interval_change(this);" value="1" checked/> Speed 1
                <input type="radio" name="interval" onclick="interval_change(this);" value=1.5 /> Speed 2
                <input type="radio" name="interval" onclick="interval_change(this);" value="2" /> Speed 3
            </div>
            <div style="float:left;width:40%;height:50%;">
                <div>Missing data on grey areas.</div>
                <div id="geo_map"></div>
            </div>
        </div>
    </div>
        </div>
        <div id="chart_label_div" class="chart_label_container">
            <div style="float:left;width:43%;height:50%;">
                <h3>Color Label & Country Checkbox</h3>
                <div id="bubble_label_div" style="float:left;width:50%;"></div>
                <div id="country_checkbox_scroll" style="float:left;width:50%;"></div>
            </div>
            <div style="float:left;width:57%;height:50%;">
                <h3>Number of countries in per region</h3>
                <div id="country_region_barchart"></div>
                <h3>Number of countries with each government type</h3>
                <div id="country_govern_barchart"></div>
            </div>
        </div>
    </div>

</body>

</html>